>Για την επίλυση της άσκησης 1: **ZOOMBA**

*Η επίλυση της άσκησης στηρίζεται στη χρήση της BFS, μία μέθοδος αναζήτησης η οποία χρησιμοποιείται για την εύρεση της βέλτιστης διαδρομής από ένα σημείο σε ένα άλλο, το οποίο είναι και το ζητούμενο της εργασίας. Βασική ιδέα του αλγορίθμου είναι η εξέταση όλων τον γειτονικών κόμβων για κάθε κόμβο μέχρι να φτάσουμε στον στόχο.*

* Αρχικά ορίζεται μια αυτοαναφορική δομή Node (που θα αποτελεί κάθε σημείο στο κωδικοποιημένο δωμάτιο), τα μέλη της οποίας είναι: 
    * Οι συντεταγμένες του σημείου(γραμμές και στήλες).
    * Ένας δείκτης σε μία δομή Node μέσω του οποίου θα συνδέονται επιλεγμένοι κόμβοι ώστε να δημιουργηθεί το βέλτιστο μονοπάτι (αποτελεί τον κόμβο γονέα).

* Ορίζεται μια συνάρτηση ```Node* createNode(int row, int col, Node* parent)```, η οποία:
    * Δεσμεύει χώρο για μια δομή τύπου Node και αρχικοποιεί κατάληλλα τα μέλη της.
    * Η συνάρτηση επιστρέφει έναν δείκτη στον κόμβο που δημιουργήθηκε.

* Ορίζεται η συνάρτηση ```isValid``` η οποία επιστρέφει 1 αν το σημείο που δέχεται είναι έγκυρο (δηλαδή είναι 0) και είναι εντος των ορίων του πίνακα και 0 σε άλλη περίπτωση.

* Ορίζεται η συνάρτηση ```void printPath(Node* targetNode)```, η οποία δέχεται σαν όρισμα ένα δείκτη σε ένα Node (τον κόμβο - στόχο) και αναδρομικά εκτυπώνει το μονοπάτι από το κόμβο - στόχο προς τα πίσω μέχρι τον κόμβο εκκίνησης, ακολουθώντας τους δείκτες - γονείς κάθε κόμβου. Η αναδρομή λειτουργεί ως εξής:
    * Base case: Αν target == NULL, το οποίο υποδεικνύει ότι φτάσαμε στο αρχικό σημείο ή αν target->parent == NULL, το οποίο υποδεικνύει λάθος μιας και δείχνει οτι το μονοπάτι δεν έχει κατασκευαστεί σωστά. Σε οποιαδήποτε από τις 2 περιπτώσεις η συνάρτηση επιστρέφει και σταματάει η αναδρομή.
    * Μετά την αναδρομική κλήση εκτυπώνεται η κίνηση που είναι απαραίτητη ώστε να φτάσουμε στον στόχο μας: 
        * Αν είναι στην ίδια σειρά ελέγεται αν ο target node είναι δεξιά ή αριστερά από τον parent node.
        *  Αν είναι στην ίδια στήλη ελέγεται αν ο target node είναι πάνω ή κάτω από τον parent node.

* Ορίζεται η main η οποία λειτουργεί ως εξής:
    * Διαβάζει αρχικά την διάσταση του δωματίου και την καταχωρεί στην μεταβλητή dimension.Σε περίπτωση που το αποτέλεσμα της scanf είναι διάφορο του 1 τοτε εμφανιζει το μήνυμα ```Error reading dimension``` και επιστρέφει 1.
    * Διαβάζει τις συντεταγμένες της θέσης εκκίνησης και στόχου και τις καταχωρεί στις εξής τιμες αντιστοίχως: zoombaX, zoombaY, targetX, targetY. Σε περίπτωση που το αποτέλεσμα της scanf είναι διάφορο του 4 τοτε εμφανιζει το μήνυμα ```Error reading positions``` και επιστρέφει 1.
    * Ορίζει εναν δισδιάστατο πίνακα room και κάνει δυναμική δέσμευση μνήμης για αυτόν με την βοήθεια της διάστασης (dimension).Σε περίπτωση που η δέσμευση μνήμης δεν είναι επιτυχής εμφανίζει το μήνυμα ```Failed to allocate memory```  και επιστρέφει 1.
    * Δέχεται απο τον χρήστη τα περιεχόμενα του πίνακα ένα - ένα και σε περίπτωση που κάποιο απο αυτά δεν είναι 0 ή 1 εμφανίζει ```Invalid input for room layout``` και αποδεσμεύει με την χρήση ενός **for (int k = 0; k <= i; k++)** κάθε γραμμή του πίνακα. Έπειτα αποδεσμεύει την μνήμη για τον πίνακα. Σε καθε άλλη περίπτωση καταχωρεί το στοιχείο που διαβάστηκε στο αντίστοιχο κελί του πίνακα. Για μετατροπή από char σε int, αφαιρούμε από το char to '0'. Με αυτόν τον τρόπο παίρνουμε ακέραιο. Για παράδειγμα '3'(ascii κωδικός 51) -'0'(ascii κωδικός 48) = 3 (ακέραιος αριθμός).
    * Καλεί την συνάρτηση ```findPath(room, zoombaX, zoombaY, targetX, targetY, dimension)```.
    * Αποδεσμεύει την μνήμη του πίνακα.